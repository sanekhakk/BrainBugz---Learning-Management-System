// src/context/AuthContext.jsx
import React, { createContext, useContext, useEffect, useState } from "react";
import { auth, db, secondaryAuth } from "../firebase";
import {
  signInWithEmailAndPassword,
  createUserWithEmailAndPassword,
  signOut as firebaseSignOut,
  onAuthStateChanged,
  sendPasswordResetEmail
} from "firebase/auth";

import {
  getUserProfileRef,
  getUserSummaryRef,
  SUBJECT_OPTIONS,
  CURRICULUM,
  getProgressRef
} from "../utils/paths";

import {
  doc,
  setDoc,
  getDoc,
  serverTimestamp,
  updateDoc,
  arrayUnion,
  arrayRemove // ADDED arrayRemove
} from "firebase/firestore";

const AuthContext = createContext();
export const useAuth = () => useContext(AuthContext);

export const AuthProvider = ({ children }) => {
  const [userId, setUserId] = useState(null);
  const [role, setRole] = useState("guest");
  const [isAuthReady, setIsAuthReady] = useState(false);

  const [showLoginModal, setShowLoginModal] = useState(false);
  const [modalRole, setModalRole] = useState(null);

  // fetch role from Firestore profile document (/users/{uid})
  const fetchUserRole = async (uid) => {
    try {
      const docRef = getUserProfileRef(uid);
      const snap = await getDoc(docRef);
      return snap.exists() ? snap.data().role : "guest";
    } catch (e) {
      console.error("fetchUserRole err:", e);
      return "guest";
    }
  };

  useEffect(() => {
    const unsub = onAuthStateChanged(auth, async (user) => {
      if (user) {
        setUserId(user.uid);
        const r = await fetchUserRole(user.uid);
        setRole(r);
      } else {
        setUserId(null);
        setRole("guest");
      }
      setIsAuthReady(true);
    });

    return () => unsub();
  }, []);

  const openLoginModal = (targetRole) => {
    setModalRole(targetRole);
    setShowLoginModal(true);
  };
  const closeLoginModal = () => {
    setShowLoginModal(false);
    setModalRole(null);
  };

  const loginUser = async (email, password) => {
    try {
      const result = await signInWithEmailAndPassword(auth, email, password);
      const uid = result.user.uid;

      const r = await fetchUserRole(uid);
      if (r === "guest") {
        // If there's no role in Firestore, treat as unauthorized
        await firebaseSignOut(auth);
        return { success: false, error: "Unauthorized account. Contact admin." };
      }

      setRole(r);
      closeLoginModal();
      return { success: true };
    } catch (error) {
      console.error("loginUser err:", error);
      return { success: false, error: "Invalid email or password." };
    }
  };

  const sendPasswordReset = async (email) => {
    try {
      await sendPasswordResetEmail(auth, email);
      return { success: true, message: "Password reset email sent!" };
    } catch (err) {
      console.error("sendPasswordReset err:", err);
      return { success: false, error: "Failed to send reset email." };
    }
  };

  const logout = async () => {
    try {
      await firebaseSignOut(auth);
    } catch (e) {
      console.error("logout err:", e);
    }
  };

  // ADMIN CREATE USER - UPDATED
const adminRegisterUser = async (form, regRole) => {
  try {
    const { email, password, name } = form;

    // Ensure admin is signed in (we rely on admin's ID token)
    const currentUser = auth.currentUser;
    if (!currentUser) {
      return { success: false, error: "Admin must be signed in" };
    }

    const idToken = await currentUser.getIdToken(/* forceRefresh */ true);

    // Call backend
    const resp = await fetch(`${import.meta.env.VITE_API_URL}/admin/create-user`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${idToken}`
      },
      body: JSON.stringify({
        name,
        email,
        password,
        role: regRole,
        // other optional fields taken from form if present
        contactNumber: form.contactNumber || "",
        classLevel: form.classLevel || "",
        emergencyContact: form.emergencyContact || "",
        subjects: form.subjects || [],
        qualifications: form.qualifications || "",
        hourlyRate: form.hourlyRate || "",
        // studentId field is removed as it's auto-generated by the backend
        // NEW STUDENT FIELDS FOR ASSIGNMENT
        syllabus: form.syllabus || "", // NEW
        mediumOfCommunication: form.mediumOfCommunication || "", // NEW
        assignments: form.assignments || [] ,// NEW
        permanentClassLink: form.permanentClassLink || "",
      })
    });

    const data = await resp.json();
    if (!resp.ok) {
      return { success: false, error: data?.error || "Registration failed" };
    }

    return { success: true, message: data.message || `${regRole} created successfully` };

  } catch (err) {
    console.error("adminRegisterUser (frontend) err:", err);
    return { success: false, error: err.message || "Failed to create user" };
  }
};

// ADMIN DELETE USER (FIXED RESILIENCE ISSUE)
const adminDeleteUser = async (uid) => {
  try {
    const currentUser = auth.currentUser;
    if (!currentUser) {
      return { success: false, error: "Admin must be signed in" };
    }

    const idToken = await currentUser.getIdToken(/* forceRefresh */ true);

    // Call backend DELETE endpoint
    const resp = await fetch(`${import.meta.env.VITE_API_URL}/admin/delete-user/${uid}`, {
      method: "DELETE", // Use DELETE method
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${idToken}`
      },
    });

    // Handle non-2xx status codes
    if (!resp.ok) {
        // Try to read the response body as text first in case it's not JSON (like HTML error page)
        let errorBody = await resp.text();
        let errorMessage = `User deletion failed with status ${resp.status}.`;

        try {
            // Attempt to parse as JSON if possible
            const data = JSON.parse(errorBody);
            errorMessage = data?.error || errorMessage;
        } catch (e) {
            // If parsing fails (non-JSON response like HTML), attach a generic error message
            console.error("Backend error response was not JSON:", errorBody);
            errorMessage = `Server error: Check backend console for details. (Status: ${resp.status})`;
        }
        
        return { success: false, error: errorMessage };
    }


    // Handle 200 OK responses
    // Since the body might be empty for a successful 204 or a successful 200 without a payload
    let data = {};
    try {
        data = await resp.json();
    } catch (e) {
        // If parsing fails on 200/204, assume success with no message.
    }

    return { success: true, message: data.message || `User ${uid} deleted successfully` };

  } catch (err) {
    console.error("adminDeleteUser (frontend) err:", err);
    return { success: false, error: err.message || "Failed to delete user due to network error" };
  }
};

// NEW: ADMIN DELETE CLASS
const adminDeleteClass = async (classId) => {
  try {
    const currentUser = auth.currentUser;
    if (!currentUser) {
      return { success: false, error: "Admin must be signed in" };
    }

    const idToken = await currentUser.getIdToken(/* forceRefresh */ true);

    // Call backend DELETE endpoint
    const resp = await fetch(`${import.meta.env.VITE_API_URL}/admin/class/${classId}`, {
      method: "DELETE", // Use DELETE method
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${idToken}`
      },
    });

    const data = await resp.json();
    if (!resp.ok && resp.status !== 200) { 
      return { success: false, error: data?.error || "Class deletion failed" };
    }

    return { success: true, message: data.message || `Class ${classId} deleted successfully` };

  } catch (err) {
    console.error("adminDeleteClass (frontend) err:", err);
    return { success: false, error: err.message || "Failed to delete class" };
  }
};

const adminUpdateUser = async (uid, form) => {
  try {
    const currentUser = auth.currentUser;
    if (!currentUser) {
      return { success: false, error: "Admin must be signed in" };
    }

    const idToken = await currentUser.getIdToken(/* forceRefresh */ true);

    const resp = await fetch(`${import.meta.env.VITE_API_URL}/admin/update-user/${uid}`, {
      method: "PUT", // Use PUT method for updates
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${idToken}`
      },
      body: JSON.stringify(form)
    });

    const data = await resp.json();
    if (!resp.ok) {
      return { success: false, error: data?.error || "Update failed" };
    }

    return { success: true, message: data.message || `${form.role} updated successfully` };

  } catch (err) {
    console.error("adminUpdateUser (frontend) err:", err);
    return { success: false, error: err.message || "Failed to update user" };
  }
};

// NEW: TUTOR MARK ATTENDANCE
const tutorMarkAttendance = async (classId, studentId, status, summary) => {
    try {
        if (role !== "tutor") {
            return { success: false, error: "Only tutors can mark attendance." };
        }
        
        const classRef = doc(db, "classes", classId);

        await updateDoc(classRef, {
            status: status, // 'completed' or 'missed'
            summary: summary, // topic taken or reason for absence
            markedAt: serverTimestamp(),
            studentAttendance: status === 'completed' ? 'present' : 'absent' 
        });

        return { success: true, message: `Attendance marked as ${status}.` };

    } catch (err) {
        console.error("tutorMarkAttendance err:", err);
        return { success: false, error: err.message || "Failed to mark attendance" };
    }
};

// TUTOR UPDATE CHAPTER PROGRESS (ADD)
const tutorUpdateChapterProgress = async (studentId, subject, chapter) => {
    try {
        if (role !== "tutor") {
            return { success: false, error: "Only tutors can update progress." };
        }
        
        // Use the path utility function
        const progressRef = getProgressRef(studentId, subject);

        // Atomically add the chapter to the completedChapters array (creates the doc if it doesn't exist)
        await setDoc(progressRef, {
            studentId,
            subject,
            completedChapters: arrayUnion(chapter), // Use arrayUnion to prevent duplicates
            updatedAt: serverTimestamp(),
        }, { merge: true });

        return { success: true, message: `Progress updated: ${chapter} completed in ${subject}.` };

    } catch (err) {
        console.error("tutorUpdateChapterProgress err:", err);
        return { success: false, error: err.message || "Failed to update progress" };
    }
};

// NEW: TUTOR DELETE CHAPTER PROGRESS (DELETE)
const tutorDeleteChapterProgress = async (studentId, subject, chapter) => {
    try {
        if (role !== "tutor") {
            return { success: false, error: "Only tutors can delete progress." };
        }
        
        const progressRef = getProgressRef(studentId, subject);

        // Atomically remove the chapter string from the completedChapters array
        await updateDoc(progressRef, {
            completedChapters: arrayRemove(chapter), 
            updatedAt: serverTimestamp(),
        });

        return { success: true, message: `Progress updated: Removed chapter "${chapter}" from ${subject}.` };

    } catch (err) {
        console.error("tutorDeleteChapterProgress err:", err);
        return { success: false, error: err.message || "Failed to delete progress" };
    }
};


  const value = {
    userId,
    role,
    isAuthReady,
    showLoginModal,
    modalRole,
    openLoginModal,
    closeLoginModal,
    loginUser,
    sendPasswordReset,
    logout,
    adminRegisterUser,
    adminDeleteUser,
    adminDeleteClass ,
    adminUpdateUser,
    tutorMarkAttendance,
    tutorUpdateChapterProgress,
    tutorDeleteChapterProgress // ADDED
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};